<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Wave Simulation</title>
    <!-- Import Three.js library -->
    <script src="three.min.js"></script>
</head>
<body onclick="callSimulation()">
    <script>
        
        // Simulation parameters
        let roomWidth = 45; // Width of the room in meters
        let roomHeight = 3; // Height of the room in meters
        let roomDepth = 45; // Depth of the room in meters
        let soundSpeed = 343; // Speed of sound in air in m/s (at room temperature)
        let distanceToWall = 40; // Distance from the sound source to the wall obstacle in meters
        let wallAbsorptionCoefficient = 0.5; // Coefficient of sound absorption of the walls (range: 0 to 1)

        // Initialize Three.js scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create walls for the room
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x800080 }); // Purple color for walls
        const wallGeometry = new THREE.BoxGeometry(roomWidth, roomHeight, roomDepth); // Dimensions of the room (adjust as needed)
        const walls = [];

        // Create each wall and position it accordingly
        const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
        leftWall.position.set(-roomWidth / 2, 0, 0);
        leftWall.rotation.y = Math.PI / 2;
        walls.push(leftWall);

        const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
        rightWall.position.set(roomWidth / 2, 0, 0);
        rightWall.rotation.y = Math.PI / 2;
        walls.push(rightWall);

        const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
        backWall.position.set(0, 0, -roomDepth / 2);
        walls.push(backWall);

        const frontWall = new THREE.Mesh(wallGeometry, wallMaterial);
        frontWall.position.set(0, 0, roomDepth / 2);
        walls.push(frontWall);

        const topWall = new THREE.Mesh(wallGeometry, wallMaterial);
        topWall.position.set(0, roomHeight / 2, 0);
        topWall.rotation.x = Math.PI / 2;
        walls.push(topWall);

        const bottomWall = new THREE.Mesh(wallGeometry, wallMaterial);
        bottomWall.position.set(0, -roomHeight / 2, 0);
        bottomWall.rotation.x = Math.PI / 2;
        walls.push(bottomWall);

        // Add walls to the scene
        walls.forEach(wall => {
            scene.add(wall);
        });

        // Create a sound source object (e.g., a sphere)
        const sourceGeometry = new THREE.SphereGeometry(0.1, 32, 32);
        const sourceMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue color
        const soundSource = new THREE.Mesh(sourceGeometry, sourceMaterial);
        soundSource.position.set(-2, -1.5, -1); // Set position of sound source
        scene.add(soundSource);

        let analyser;

        // Function to visualize sound propagation from the source to the walls
        function visualizeSoundPropagation(soundSource, walls) {
            const speedOfSound = 343; // Speed of sound in air in meters per second

            // Calculate distance from sound source to each wall
            const distancesToWalls = walls.map(wall => soundSource.position.distanceTo(wall.position));

            // Calculate time for sound wave to reach each wall
            const timesToWalls = distancesToWalls.map(distance => distance / speedOfSound);

            // Create visualization objects for sound propagation to each wall
            const propagationObjects = [];
            timesToWalls.forEach((time, index) => {
                const geometry = new THREE.SphereGeometry(0.05, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green color
                const sphere = new THREE.Mesh(geometry, material);

                // Set initial position of sound propagation object at the sound source
                sphere.position.copy(soundSource.position);

                // Animate the movement of sound propagation object towards the wall
                const destination = walls[index].position;
                const movementVector = new THREE.Vector3().subVectors(destination, soundSource.position);
                movementVector.normalize(); // Normalize the movement vector
                movementVector.multiplyScalar(speedOfSound * time); // Scale by speed and time to get displacement
                animateSoundPropagation(sphere, movementVector, time); // Start animation

                // Add the sound propagation object to the scene
                scene.add(sphere);
                propagationObjects.push(sphere);
            });

            return propagationObjects;
        }

        // Function to animate the movement of sound propagation object
        function animateSoundPropagation(object, movementVector, duration) {
            const startPosition = object.position.clone();
            const startTime = Date.now();

            function update() {
                const elapsedTime = (Date.now() - startTime) / 1000; // Convert milliseconds to seconds
                if (elapsedTime < duration) {
                    const progress = elapsedTime / duration;
                    object.position.copy(startPosition.clone().add(movementVector.clone().multiplyScalar(progress)));
                    requestAnimationFrame(update);
                } else {
                    // Animation complete
                    object.position.copy(startPosition.clone().add(movementVector)); // Ensure final position is reached
                }
            }

            // Start animation loop
            update();
        }

        // Load and play the sound/music file
        async function loadSound(soundURL) {
            debugger;
            try {
                if (analyser == null)
                {
                    // Initialize Web Audio API context
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    const response = await fetch(soundURL, {
                        method: "GET",
                        mode: 'cors',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    // Decode it
                    arrayBuffer = await audioContext.decodeAudioData(await response.arrayBuffer());
                    audioSource = audioContext.createBufferSource();
                    audioSource.buffer = arrayBuffer;
                    //audioSource.connect(audioContext.destination);

                    // Create AnalyserNode to analyze the audio data
                    analyser = audioContext.createAnalyser();
                    audioSource.connect(analyser);
                    analyser.connect(audioContext.destination);

                    // Start playing the audio
                    audioSource.start();

                    // Simulate sound waves propagation and reflections with input parameters
                    simulateSoundWaves(20, 40, 0.5);
                }
            } catch (err) {
                console.error(`Unable to fetch the audio file. Error: ${err.message}`);
            }
        }

        // Simulate sound wave propagation and reflections
        function simulateSoundWaves(roomTemp, wallDistance, absorptionCoefficient) {
            debugger;
            if (!analyser) return;

            // Set simulation parameters based on input
            soundSpeed = 331.4 + (0.6 * roomTemp);
            distanceToWall = wallDistance;
            wallAbsorptionCoefficient = absorptionCoefficient;

            for (let x = 0; x < roomWidth; x++) {
                for (let y = 0; y < roomHeight; y++) {
                    for (let z = 0; z < roomDepth; z++) {
                        const listenerPosition = new THREE.Vector3(x, y, z);
                        const distance = soundSource.position.distanceTo(listenerPosition);
                        const timeToReach = distance / soundSpeed;

                        // Calculate direction vector from sound source to listener
                        const direction = listenerPosition.clone().sub(soundSource.position).normalize();

                        // Calculate angle of incidence
                        const angleOfIncidence = Math.acos(direction.dot(new THREE.Vector3(0, 0, 1))) * (180 / Math.PI);

                        // Calculate angle of reflection (assuming perfect reflection off walls)
                        //const angleOfReflection = angleOfIncidence;
                        const angleOfReflection = calculateReflectionAngle(angleOfIncidence)

                        // Create a sphere at the listener position with a delay based on timeToReach
                        setTimeout(() => {
                            const listenerGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                            const listenerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                            const listenerSphere = new THREE.Mesh(listenerGeometry, listenerMaterial);

                            //// Apply rotation based on angle of reflection
                            //listenerSphere.rotateX((angleOfReflection - 90) * (Math.PI / 180));
                            
                            // Convert reflection angle to radians
                            const reflectionAngleRad = THREE.MathUtils.degToRad(angleOfReflection);

                            // Rotate the sound wave visualization around the Z-axis
                            listenerSphere.rotation.z = reflectionAngleRad;

                            listenerSphere.position.copy(listenerPosition);

                            // Get the frequency data from the analyser
                            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                            analyser.getByteFrequencyData(frequencyData);

                            // Update the visualization based on the frequency data
                            const averageFrequency = getAverageFrequency(frequencyData);

                            //// Calculate scaling factor based on average frequency (adjust as needed)
                            //const scaleFactor = averageFrequency / 255; // Normalize to range [0, 1]
                            //// Update size of the sound waves
                            //listenerSphere.scale.set(scaleFactor, scaleFactor, scaleFactor);

                            // Update color of the sound waves (optional)
                            const newColor = new THREE.Color().setHSL(averageFrequency / 255, 1, 0.5); // Adjust color based on average frequency
                            listenerSphere.material.color.copy(newColor);

                            // Update position of the sound waves (optional)
                            //const newPosition = new THREE.Vector3(x, y, -2 - averageFrequency * 0.1); // Adjust position based on average frequency
                            //const newPosition = calculateReflectionPositionWithAudio(listenerPosition, angleOfReflection, averageFrequency);
                            //listenerSphere.position.copy(newPosition);

                            scene.add(listenerSphere);
                        }, timeToReach * 1000); // Convert time to milliseconds
                    }
                }
            }

            // Call simulateSoundWaves recursively to update the simulation continuously
            requestAnimationFrame(simulateSoundWaves);
        }

        // Function to calculate the average frequency from frequency data
        function getAverageFrequency(frequencyData) {
            let sum = 0;
            for (let i = 0; i < frequencyData.length; i++) {
                sum += frequencyData[i];
            }
            return sum / frequencyData.length;
        }

        // Function to calculate reflection angle based on incident angle
        function calculateReflectionAngle(incidentAngle) {
            // Calculate reflection angle using the law of reflection
            // Angle of reflection = 2 * (Angle of incidence - 90 degrees)
            const reflectionAngle = 2 * (incidentAngle - 90); // Adjust as needed based on coordinate system

            return reflectionAngle;
        }

        // Function to calculate new position after reflection with audio modulation
        function calculateReflectionPositionWithAudio(position, reflectionAngle, audioFactor) {
            // Convert reflection angle to radians
            const reflectionAngleRad = THREE.MathUtils.degToRad(reflectionAngle);
            
            // Calculate modulation factor based on audio data (e.g., frequency or amplitude)
            const modulationFactor = audioFactor * 0.1; // Adjust the modulation intensity as needed
            
            // Calculate new position after reflection using trigonometry
            // Apply modulation to the reflection position
            const newX = position.x * Math.cos(reflectionAngleRad) - position.y * Math.sin(reflectionAngleRad) + modulationFactor;
            const newY = position.x * Math.sin(reflectionAngleRad) + position.y * Math.cos(reflectionAngleRad) + modulationFactor;

            // Return the modulated position
            return new THREE.Vector3(newX, newY, position.z);
        }

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function callSimulation()
        {
            // Update camera position
            // Set camera position and orientation to view the room
            camera.position.set(0, 0, 10); // Position the camera outside the room
            camera.lookAt(0, 0, 0); // Orient the camera towards the center of the room
            camera.fov = 75; // Field of view angle (adjust as needed)
            camera.aspect = window.innerWidth / window.innerHeight; // Aspect ratio
            camera.near = 0.1; // Near clipping plane distance
            camera.far = 100; // Far clipping plane distance
            camera.updateProjectionMatrix(); // Update camera projection matrix

            // Visualize sound propagation from the source to the walls
            const propagationObjects = visualizeSoundPropagation(soundSource, walls);

            // Call the function with the path to your sound/music file
            loadSound('arcade fire - ready to start.mp3');

            animate();
        }

    </script>
</body>
</html>
